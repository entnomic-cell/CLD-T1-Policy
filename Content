# Check for Administrator privileges
$IsAdmin = ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)

if (-not $IsAdmin) {
    Write-Host "`n[WARNING] Admin privileges required." -ForegroundColor Red
    Write-Host "[ACTION] Run PowerShell as Administrator." -ForegroundColor Yellow
    Pause
    exit 1
}

# Function to write colored text
function Write-ColoredLine {
    param (
        [string]$Text,
        [ConsoleColor]$Color = 'White'
    )
    $oldColor = $Host.UI.RawUI.ForegroundColor
    $Host.UI.RawUI.ForegroundColor = $Color
    Write-Host $Text
    $Host.UI.RawUI.ForegroundColor = $oldColor
}

# Function to wait for Enter key
function Wait-ForEnter {
    param([string]$Message = "Press Enter to Continue")
    Write-ColoredLine $Message 'Yellow'
    while (-not [System.Console]::KeyAvailable -or [System.Console]::ReadKey($true).Key -ne "Enter") {
        Start-Sleep -Milliseconds 50
    }
}

# Custom loading bar - Lightweight spinner
function Show-CustomLoadingBar {
    $symbols = @('⠋', '⠙', '⠹', '⠸')
    $i = 0
    for ($p = 0; $p -le 100; $p += 25) {
        $bar = '█' * ($p / 10) + '░' * (10 - ($p / 10))
        Write-Host -NoNewline "`rScan: [$bar] $p% $($symbols[$i % 4])" -ForegroundColor Cyan
        Start-Sleep -Milliseconds 100
        $i++
    }
    Write-Host "`n"
}

# File open logging with popup
$logFile = "C:\ToolsCLD\file_log.txt"
function Start-FileWatcher {
    try {
        $watcher = New-Object System.IO.FileSystemWatcher
        $watcher.Path = "C:\"
        $watcher.IncludeSubdirectories = $true
        $watcher.EnableRaisingEvents = $true
        $watcher.NotifyFilter = [System.IO.NotifyFilters]::FileName -bor [System.IO.NotifyFilters]::LastAccess
        $wshell = New-Object -ComObject WScript.Shell

        $action = {
            $path = $Event.SourceEventArgs.FullPath
            $time = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
            Add-Content -Path $logFile -Value "[$time] Opened: $path" -ErrorAction SilentlyContinue
            $wshell.Popup("This application was opened: $path", 5, "File Access", 64)
        }

        Register-ObjectEvent -InputObject $watcher -EventName Created -SourceIdentifier FileCreated -Action $action
        Register-ObjectEvent -InputObject $watcher -EventName Changed -SourceIdentifier FileChanged -Action $action
    } catch {
        Write-ColoredLine "[WARNING] File watcher setup failed." Yellow
    }
}

# Clear screen and display header
Clear-Host
Write-Host "  ____ _     ____    _____ _   ____       _ _            " -ForegroundColor Red
Write-Host " / ___| |   |  _ \  |_   _/ | |  _ \ ___ | (_) ___ _   _ " -ForegroundColor Red
Write-Host "| |   | |   | | | |   | | | | | |_) / _ \| | |/ __| | | |" -ForegroundColor Red
Write-Host "| |___| |___| |_| |   | | | | |  __/ (_) | | | (__| |_| |" -ForegroundColor Red
Write-Host " \____|_____|____/    |_| |_| |_|   \___/|_|_|\___|\__, |" -ForegroundColor Red
Write-Host "                                                   |___/  " -ForegroundColor Red
Write-ColoredLine ""
Write-ColoredLine "=== CLD T1 POLICY ===" Cyan
Write-ColoredLine "Anti-Cheat Scanner by Entnomic" 'Magenta'
Write-ColoredLine "Pass all the steps." White
Write-ColoredLine "Tools saved to C:\ToolsCLD." White
Write-ColoredLine "Admin required." White
Write-Host ""

# Check CPU
$cpu = Get-CimInstance Win32_Processor -ErrorAction SilentlyContinue | Select-Object -First 1
if ($cpu -and $cpu.NumberOfCores -ge 4 -and $cpu.MaxClockSpeed -ge 2500) {
    Write-ColoredLine "CPU: $($cpu.Name)" Green
    Write-ColoredLine "✓ Good performance." Green 
} else {
    Write-ColoredLine "CPU: $($cpu.Name)" Red
    Write-ColoredLine "⚠ Slower scans possible." Yellow
}
Write-Host ""

# Check GPU
$gpu = Get-CimInstance Win32_VideoController -ErrorAction SilentlyContinue | Select-Object -First 1
$gpuName = $gpu.Name
$goodGPUs = @("RTX 30", "RTX 40", "RX 6000", "RX 7000")
$gpuIsGood = $goodGPUs | Where-Object { $gpuName -like "*$_*" }
if ($gpuIsGood) {
    Write-ColoredLine "GPU: $gpuName" Green
    Write-ColoredLine "✓ Optimal." Green 
} else {
    Write-ColoredLine "GPU: $gpuName" Red
    Write-ColoredLine "⚠ May impact performance." Yellow
}

Write-ColoredLine ""
Write-ColoredLine "=== Credits ===" Cyan
Write-ColoredLine "Made by Entnomic" 'Magenta'
Write-Host ""
Wait-ForEnter -Message "Press Enter to Start"
Clear-Host

# Start file watcher
New-Item -ItemType Directory -Path "C:\ToolsCLD" -ErrorAction SilentlyContinue | Out-Null
Start-FileWatcher

# ====== STEP 1: CORE SYSTEM CHECK ======
Write-ColoredLine "Step 1/4: System Integrity" White
Write-ColoredLine "Checking security..." Cyan
Show-CustomLoadingBar

$modulesOutput = @()
$windowsOutput = @()
$memoryIntegrityOutput = @()
$defenderOutput = @()
$exclusionsOutput = @()
$threatsOutput = @()
$powershellSigOutput = @()

$defaultModules = @("Microsoft.PowerShell.Archive", "Microsoft.PowerShell.Diagnostics", "Microsoft.PowerShell.Host", "Microsoft.PowerShell.LocalAccounts", "Microsoft.PowerShell.Management", "Microsoft.PowerShell.Security", "Microsoft.PowerShell.Utility", "PackageManagement", "PowerShellGet", "PSReadLine", "Pester", "ThreadJob")
$protectedModule = "Microsoft.PowerShell.Operation.Validation"
$modulesPath = "C:\Program Files\WindowsPowerShell\Modules"

# Minimal module check
$modules = Get-ChildItem $modulesPath -Directory -ErrorAction SilentlyContinue
foreach ($module in $modules) {
    $moduleName = $module.Name
    if ($moduleName -eq $protectedModule) {
        $modulesOutput += "SUCCESS: Protected module verified."
    } elseif ($moduleName -notin $defaultModules) {
        $modulesOutput += "FAILURE: Unauthorized module: $moduleName"
    }
}
if (-not $modulesOutput) { $modulesOutput += "SUCCESS: No unauthorized modules." }

$windowsOutput += if ($env:OS -eq "Windows_NT") { "SUCCESS: Windows OS." } else { "FAILURE: Non-Windows OS." }

try {
    $enabled = Get-ItemPropertyValue "HKLM:\SYSTEM\CurrentControlSet\Control\DeviceGuard\Scenarios\HypervisorEnforcedCodeIntegrity" -Name "Enabled" -ErrorAction Stop
    $memoryIntegrityOutput += if ($enabled -eq 1) { "SUCCESS: Memory Integrity ON." } else { "FAILURE: Memory Integrity OFF." }
} catch {
    $memoryIntegrityOutput += "WARNING: Memory Integrity check failed."
}

try {
    $defender = Get-MpComputerStatus -ErrorAction Stop
    $defenderOutput += if ($defender.AntivirusEnabled -and $defender.RealTimeProtectionEnabled) { "SUCCESS: Defender active." } else { "FAILURE: Defender not active." }
} catch {
    $defenderOutput += "WARNING: Defender check failed."
}

$exclusionsOutput += if ((Get-MpPreference).ExclusionPath) { "FAILURE: Exclusions found." } else { "SUCCESS: No exclusions." }

$threatsOutput += if ((Get-MpThreat).Count -eq 0) { "SUCCESS: No threats." } else { "FAILURE: Threats detected." }

try {
    $sig = Get-AuthenticodeSignature "$env:SystemRoot\System32\WindowsPowerShell\v1.0\powershell.exe"
    $powershellSigOutput += if ($sig.Status -eq 'Valid' -and $sig.SignerCertificate.Subject -like '*Microsoft Windows*') { "SUCCESS: PowerShell signed." } else { "FAILURE: PowerShell signature invalid." }
} catch {
    $powershellSigOutput += "WARNING: PowerShell signature check failed."
}

function Write-Section {
    param([string]$Title, [string[]]$Lines)
    Write-ColoredLine "--- $Title ---" Cyan
    foreach ($line in $Lines) {
        if ($line -match "^SUCCESS") { Write-ColoredLine "✓ $line" Green }
        elseif ($line -match "^FAILURE") { Write-ColoredLine "✗ $line" Red }
        elseif ($line -match "^WARNING") { Write-ColoredLine "! $line" Yellow }
        else { Write-ColoredLine $line Green }
    }
}

Write-Section "Modules" $modulesOutput
Write-Section "OS" $windowsOutput
Write-Section "Memory Integrity" $memoryIntegrityOutput
Write-Section "Defender" $defenderOutput
Write-Section "Exclusions" $exclusionsOutput
Write-Section "Threats" $threatsOutput
Write-Section "PowerShell" $powershellSigOutput

$allResults1 = $modulesOutput + $windowsOutput + $memoryIntegrityOutput + $defenderOutput + $exclusionsOutput + $threatsOutput + $powershellSigOutput
$total1 = ($allResults1 | Where-Object { $_ -match '^(SUCCESS|FAILURE|WARNING)' }).Count
$success1 = ($allResults1 | Where-Object { $_ -match '^SUCCESS' }).Count
$rate1 = if ($total1 -gt 0) { [math]::Round(($success1 / $total1) * 100, 0) } else { 100 }
$rateColor1 = if ($rate1 -eq 100) { "Green" } else { "Red" }

Write-ColoredLine "Step 1 Success: $rate1% ($success1/$total1)" $rateColor1
Wait-ForEnter -Message "Press Enter for Step 2"
Clear-Host

# ====== STEP 2: BAM and Prefetch CHECK ======
Write-ColoredLine "Step 2/4: BAM and Prefetch" White
Write-ColoredLine "Checking BAM entries and Prefetch..." Cyan
Show-CustomLoadingBar

$bamOutput = @()
$prefetchOutput = @()

# Suspicious lists (for checking in BAM and Prefetch)
$suspiciousFiles = @("matcha", "olduimatrix", "autoexe", "bin", "workspace", "monkeyaim", "thunderaim", "thunderclient", "celex", "release", "matrix", "matcha.exe", "triggerbot", "solara", "xeno", "wave", "cloudy", "tupical", "horizon", "myst", "celery", "zarora", "juju", "nezure", "FusionHacks.zip", "release.zip", "bootstrapper", "aimmy.exe", "aimmy", "Fluxus", "clumsy", "build", "build.zip", "build.rar", "MystW.exe", "isabelle", "dx9", "dx9ware")
$suspiciousList = @("isabelle", "xeno", "solara", "bootstrapper", "bootstrappernew", "loader", "santoware", "mystw", "severe", "mapper", "thunderclient", "monkeyaim", "olduimatrix", "matrix", "matcha")
$watchlist = @("BOOTSTRAPPERNEW.EXE", "BOOTSTRAPPER.EXE", "XENO.EXE", "XENOUI.EXE", "SOLARA.EXE", "MAPPER.EXE", "LOADER.EXE", "MATCHA.EXE", "EVOLVE.EXE")
$allSuspicious = $suspiciousFiles + $suspiciousList + $watchlist

# BAM Parser - All entries
try {
    $sid = [System.Security.Principal.WindowsIdentity]::GetCurrent().User.Value
    $bamEntries = Get-ItemProperty "HKLM:\SYSTEM\CurrentControlSet\Services\bam\State\UserSettings\$sid" -ErrorAction Stop
    $bamApps = @()
    $isSuspiciousBAM = $false
    foreach ($entry in ($bamEntries.PSObject.Properties | Where-Object { $_.Name -notlike "PS*" })) {
        if ($entry.Value.Length -ge 8) {
            $timestamp = [BitConverter]::ToInt64($entry.Value, 0)
            $date = [DateTime]::FromFileTime($timestamp)
            $appPath = $entry.Name
            $isSuspicious = $allSuspicious | Where-Object { $appPath -imatch $_ }
            $bamApps += [PSCustomObject]@{Text = "$appPath - Last: $date"; Color = if ($isSuspicious) { "Red" } else { "Green" }}
            if ($isSuspicious) { $isSuspiciousBAM = $true }
        }
    }
    if ($bamApps) {
        $bamOutput += "SUCCESS: Found $($bamApps.Count) BAM entries."
        if ($isSuspiciousBAM) { $bamOutput += "FAILURE: Suspicious BAM detected." }
        foreach ($app in $bamApps) { $bamOutput += $app.Text }
    } else {
        $bamOutput += "SUCCESS: No BAM entries."
    }
} catch {
    $bamOutput += "WARNING: BAM access failed."
}

# Prefetch Parser - All entries
try {
    $prefetchFiles = Get-ChildItem "C:\Windows\Prefetch" -Filter "*.pf" -ErrorAction Stop
    $prefetchApps = @()
    $isSuspiciousPrefetch = $false
    foreach ($file in $prefetchFiles) {
        $appName = $file.Name.Split('-')[0]
        $isSuspicious = $allSuspicious | Where-Object { $appName -imatch $_ }
        $prefetchApps += [PSCustomObject]@{Text = "$appName - Last: $($file.LastWriteTime)"; Color = if ($isSuspicious) { "Red" } else { "Green" }}
        if ($isSuspicious) { $isSuspiciousPrefetch = $true }
    }
    if ($prefetchApps) {
        $prefetchOutput += "SUCCESS: Found $($prefetchApps.Count) Prefetch entries."
        if ($isSuspiciousPrefetch) { $prefetchOutput += "FAILURE: Suspicious Prefetch detected." }
        foreach ($app in $prefetchApps) { $prefetchOutput += $app.Text }
    } else {
        $prefetchOutput += "SUCCESS: No Prefetch entries."
    }
} catch {
    $prefetchOutput += "WARNING: Prefetch access failed."
}

Write-ColoredLine "--- BAM Entries ---" Cyan
foreach ($line in $bamOutput) {
    if ($line -match "^SUCCESS") { Write-ColoredLine "✓ $line" Green }
    elseif ($line -match "^FAILURE") { Write-ColoredLine "✗ $line" Red }
    elseif ($line -match "^WARNING") { Write-ColoredLine "! $line" Yellow }
    else { Write-ColoredLine $line ($bamApps | Where-Object { $_.Text -eq $line } | Select-Object -ExpandProperty Color -ErrorAction SilentlyContinue) }
}
Write-ColoredLine "--- Prefetch Entries ---" Cyan
foreach ($line in $prefetchOutput) {
    if ($line -match "^SUCCESS") { Write-ColoredLine "✓ $line" Green }
    elseif ($line -match "^FAILURE") { Write-ColoredLine "✗ $line" Red }
    elseif ($line -match "^WARNING") { Write-ColoredLine "! $line" Yellow }
    else { Write-ColoredLine $line ($prefetchApps | Where-Object { $_.Text -eq $line } | Select-Object -ExpandProperty Color -ErrorAction SilentlyContinue) }
}

$allResults2 = $bamOutput + $prefetchOutput
$total2 = ($allResults2 | Where-Object { $_ -match '^(SUCCESS|FAILURE|WARNING)' }).Count
$success2 = ($allResults2 | Where-Object { $_ -match '^SUCCESS' }).Count
$rate2 = if ($total2 -gt 0) { [math]::Round(($success2 / $total2) * 100, 0) } else { 100 }
$rateColor2 = if ($rate2 -eq 100) { "Green" } else { "Red" }

Write-ColoredLine "Step 2 Success: $rate2% ($success2/$total2)" $rateColor2
Wait-ForEnter -Message "Press Enter for Step 3"
Clear-Host

# ====== STEP 3: PROCESS EXPLORER ======
Write-ColoredLine "Step 3/4: Process Explorer" White
Write-ColoredLine "Launching Process Explorer. Scroll to bottom, then close." Cyan
Show-CustomLoadingBar

$processNames = @("procexp32", "procexp64", "procexp64a")
$runningPE = Get-Process -ErrorAction SilentlyContinue | Where-Object { $processNames -contains $_.ProcessName.ToLower() }

if ($runningPE) {
    Write-ColoredLine "[SUCCESS] Terminated running Process Explorer." Green
    $runningPE | ForEach-Object {
        try {
            Stop-Process -Id $_.Id -Force -ErrorAction Stop
            Write-ColoredLine "[SUCCESS] Terminated PID $($_.Id)." Green
        } catch {
            Write-ColoredLine "[FAILED] Failed to terminate PID $($_.Id)." Red
        }
    }
    Start-Sleep -Seconds 1
} else {
    Write-ColoredLine "[SUCCESS] No Process Explorer running." Green
}

$baseFolder = "C:\ToolsCLD"
$extractFolder = Join-Path $baseFolder "ProcessExplorer"
$zipUrl = "https://download.sysinternals.com/files/ProcessExplorer.zip"
$zipPath = Join-Path $baseFolder "ProcessExplorer.zip"

if (Test-Path $baseFolder) {
    Write-ColoredLine "[SUCCESS] Cleaned C:\ToolsCLD." Green
    Get-ChildItem -Path $baseFolder -Force -Recurse | ForEach-Object {
        try {
            if ($_.Attributes -band [System.IO.FileAttributes]::ReadOnly) {
                $_.Attributes = $_.Attributes -bxor [System.IO.FileAttributes]::ReadOnly
            }
            Remove-Item -LiteralPath $_.FullName -Recurse -Force -ErrorAction Stop
        } catch {
            Write-ColoredLine "[INFO] Couldn't remove $($_.FullName)." White
        }
    }
} else {
    New-Item -ItemType Directory -Path $baseFolder -ErrorAction Stop | Out-Null
    Write-ColoredLine '[SUCCESS] Created C:\ToolsCLD.' Green
}

try {
    Invoke-WebRequest -Uri $zipUrl -OutFile $zipPath -UseBasicParsing -ErrorAction Stop
    Write-ColoredLine '[SUCCESS] Downloaded Process Explorer.' Green
} catch {
    Write-ColoredLine '[FAILED] Download failed.' Red
}

try {
    Add-Type -AssemblyName System.IO.Compression.FileSystem
    [System.IO.Compression.ZipFile]::ExtractToDirectory($zipPath, $extractFolder)
    Write-ColoredLine '[SUCCESS] Extracted Process Explorer.' Green
} catch {
    Write-ColoredLine '[SUCCESS] Files already exist.' Green
}
Remove-Item $zipPath -Force -ErrorAction SilentlyContinue

$regFileUrl = "https://pastebin.com/raw/gse8NxwU"
$regFilePath = Join-Path $baseFolder "procexp_config.reg"

try {
    Invoke-WebRequest -Uri $regFileUrl -OutFile $regFilePath -UseBasicParsing -ErrorAction Stop
    Write-ColoredLine "[SUCCESS] Downloaded registry config." Green
} catch {
    Write-ColoredLine "[FAILED] Registry config download failed." Red
}

try {
    & "$env:SystemRoot\System32\cmd.exe" /c "reg import `"$regFilePath`""
    if ($LASTEXITCODE -eq 0) {
        Write-ColoredLine "[SUCCESS] Imported registry config." Green
    } else {
        Write-ColoredLine "[FAILED] Registry import failed." Red
    }
} catch {
    Write-ColoredLine "[FAILED] Registry import error." Red
}

$actualExe = Get-ChildItem -Path $extractFolder -Filter "procexp64.exe" -Recurse | Select-Object -First 1

$peOutput = @()
if ($actualExe) {
    Write-ColoredLine "[SUCCESS] Launching Process Explorer." Green
    $process = Start-Process -FilePath $actualExe.FullName -PassThru
    Start-Sleep -Seconds 1
    $wshell = New-Object -ComObject WScript.Shell
    Start-Sleep -Milliseconds 500
    $null = $wshell.AppActivate($process.Id)
    $wshell.SendKeys('% x')
    Write-ColoredLine "[SUCCESS] Process Explorer maximized." Green
    $process.WaitForExit()
    $peOutput += "SUCCESS: Process Explorer launched and closed."
} else {
    $peOutput += "FAILURE: procexp64.exe not found."
}

Write-Section "Process Explorer" $peOutput

$total3 = ($peOutput | Where-Object { $_ -match '^(SUCCESS|FAILURE|WARNING)' }).Count
$success3 = ($peOutput | Where-Object { $_ -match '^SUCCESS' }).Count
$rate3 = if ($total3 -gt 0) { [math]::Round(($success3 / $total3) * 100, 0) } else { 100 }
$rateColor3 = if ($rate3 -eq 100) { "Green" } else { "Red" }

Write-ColoredLine "Step 3 Success: $rate3% ($success3/$total3)" $rateColor3
Wait-ForEnter -Message "Press Enter for Step 4"
Clear-Host

# ====== STEP 4: MOUSE & KEYBOARD SOFTWARE CHECK ======
Write-ColoredLine "Step 4/5: Mouse and Keyboard Software Detection" White
Write-ColoredLine "Checking for gaming peripheral software..." Cyan
Show-CustomLoadingBar

$hardwareOutput = @()

# Popular gaming peripherals and software paths
$peripherals = @(
    @{Name="Razer"; Software="C:\Program Files\Razer\Synapse3\Razer Synapse.exe"},
    @{Name="Corsair"; Software="C:\Program Files (x86)\Corsair\CORSAIR iCUE Software\iCUE.exe"},
    @{Name="Logitech"; Software="C:\Program Files\Logitech\G HUB\lghub.exe"},
    @{Name="SteelSeries"; Software="C:\Program Files\SteelSeries\SteelSeries Engine 3\SteelSeriesEngine3.exe"},
    @{Name="HyperX"; Software="C:\Program Files\HyperX\NGenuity\Ngenuity.exe"},
    @{Name="ASUS"; Software="C:\Program Files (x86)\ASUS\Armoury Crate\ArmouryCrate.exe"},
    @{Name="MSI"; Software="C:\Program Files (x86)\MSI\MSI Dragon Center\MSIDragonCenter.exe"},
    @{Name="Roccat"; Software="C:\Program Files\Roccat\Roccat Swarm\RoccatSwarm.exe"},
    @{Name="CoolerMaster"; Software="C:\Program Files\Cooler Master\MasterPlus\MasterPlus.exe"},
    @{Name="EVGA"; Software="C:\Program Files (x86)\EVGA\EVGA Precision X1\PrecisionX1.exe"}
)

# Detect connected devices
try {
    $usbDevices = Get-PnpDevice -Class "Keyboard","Mouse" | Where-Object { $_.Status -eq "OK" }
    $foundPeripherals = $false
    foreach ($periph in $peripherals) {
        $deviceDetected = $usbDevices | Where-Object { $_.FriendlyName -like "*$($periph.Name)*" }
        $softwareExists = Test-Path $periph.Software

        if ($deviceDetected) {
            Write-ColoredLine "Detected $($periph.Name) hardware." Green
        }

        if ($softwareExists) {
            Write-ColoredLine "Launching $($periph.Name) software. Please go to the Macro section." Cyan
            Start-Process $periph.Software
            $foundPeripherals = $true
        }

        if (-not $deviceDetected -and -not $softwareExists) {
            Write-ColoredLine "No $($periph.Name) hardware or software found." Yellow
        }
    }

    if (-not $foundPeripherals) {
        $hardwareOutput += "SUCCESS: No supported software detected."
    } else {
        $hardwareOutput += "SUCCESS: Peripheral software check completed."
    }
} catch {
    Write-ColoredLine "! Peripheral detection failed." Yellow
    $hardwareOutput += "WARNING: Peripheral detection failed."
}

Write-Section "Mouse & Keyboard Software Check" $hardwareOutput

$total4 = ($hardwareOutput | Where-Object { $_ -match '^(SUCCESS|FAILURE|WARNING)' }).Count
$success4 = ($hardwareOutput | Where-Object { $_ -match '^SUCCESS' }).Count
$rate4 = if ($total4 -gt 0) { [math]::Round(($success4 / $total4) * 100, 0) } else { 100 }
$rateColor4 = if ($rate4 -eq 100) { "Green" } else { "Red" }

Write-ColoredLine "Step 4 Success: $rate4% ($success4/$total4)" $rateColor4

# Pause here to prevent automatic jump to Step 5
Wait-ForEnter -Message "Press Enter to continue to Step 5"
Clear-Host

# ====== STEP 5: DOWNLOADS, ACTIVE PROCESSES, REGISTRY SCAN ======
Clear-Host
Write-ColoredLine "Step 5/5: Full Cheat Detection Scan" White
Write-ColoredLine "Scanning Downloads, active processes, and registry..." Cyan
Write-ColoredLine "⚠ DO NOT CLOSE THIS WINDOW UNDER ANY CIRCUMSTANCES! ⚠" Red
Show-CustomLoadingBar

$step5Output = @()
$suspiciousCombined = @(
    "matcha","olduimatrix","autoexe","bin","workspace","monkeyaim","thunderaim","thunderclient",
    "celex","release","matrix","matcha.exe","triggerbot","solara","xeno","wave","cloudy",
    "tupical","horizon","myst","celery","zarora","juju","nezure","FusionHacks.zip","release.zip",
    "bootstrapper","aimmy.exe","aimmy","Fluxus","clumsy","build","build.zip","build.rar","MystW.exe",
    "isabelle","dx9","dx9ware","bootstrappernew","loader","santoware","mystw","severe","mapper",
    "BOOTSTRAPPERNEW.EXE","BOOTSTRAPPER.EXE","XENO.EXE","XENOUI.EXE","SOLARA.EXE","MAPPER.EXE",
    "LOADER.EXE","MATCHA.EXE","EVOLVE.EXE"
)

# --- Check Downloads folder ---
$downloadsPath = [Environment]::GetFolderPath("UserProfile") + "\Downloads"
try {
    $downloadFiles = Get-ChildItem $downloadsPath -File -Recurse -ErrorAction Stop
    foreach ($file in $downloadFiles) {
        foreach ($susp in $suspiciousCombined) {
            if ($file.Name -imatch [regex]::Escape($susp)) {
                $step5Output += "FAILURE: Suspicious file in Downloads: $($file.FullName)"
            }
        }
    }
} catch {
    $step5Output += "WARNING: Cannot access Downloads folder."
}

# --- Check active processes ---
try {
    $activeProcs = Get-Process | Select-Object -ExpandProperty ProcessName
    foreach ($proc in $activeProcs) {
        foreach ($susp in $suspiciousCombined) {
            if ($proc -imatch [regex]::Escape($susp)) {
                $step5Output += "FAILURE: Suspicious process running: $proc"
            }
        }
    }
} catch {
    $step5Output += "WARNING: Active process check failed."
}

# --- Check registry (MuiCache example) ---
try {
    $muiPath = "HKCU:\SOFTWARE\Classes\Local Settings\Software\Microsoft\Windows\Shell\MuiCache"
    $entries = Get-ItemProperty -Path $muiPath -ErrorAction Stop
    foreach ($prop in $entries.PSObject.Properties) {
        foreach ($susp in $suspiciousCombined) {
            if ($prop.Name.ToLower() -like "*$susp*") {
                $step5Output += "WARNING: Suspicious registry entry: $($prop.Name)"
            }
        }
    }
} catch {
    $step5Output += "WARNING: Cannot access MuiCache registry."
}

# --- Show Process Active History (PAH) Window ---
Start-Job {
    Add-Type -AssemblyName System.Windows.Forms
    Add-Type -AssemblyName System.Drawing

    function Show-ProcessActiveHistory {
        $form = New-Object Windows.Forms.Form
        $form.Text = "Process Active History (DO NOT CLOSE)"
        $form.WindowState = 'Maximized'
        $form.MinimumSize = New-Object Drawing.Size(800, 600)
        $form.StartPosition = "CenterScreen"
        $form.BackColor = [Drawing.Color]::White
        $form.Topmost = $true

        $listBox = New-Object Windows.Forms.ListBox
        $listBox.Dock = 'Fill'
        $listBox.Font = New-Object Drawing.Font("Consolas", 10)
        $listBox.BackColor = [Drawing.Color]::White
        $listBox.ForeColor = [Drawing.Color]::Black
        $form.Controls.Add($listBox)

        $seen = [System.Collections.Generic.HashSet[string]]::new()
        $timer = New-Object Windows.Forms.Timer
        $timer.Interval = 2000
        $timer.Add_Tick({
            $procs = Get-Process | Where-Object { $_.MainWindowTitle -or $_.ProcessName }
            foreach ($p in $procs) {
                $name = $p.ProcessName
                if (-not $seen.Contains($name)) {
                    $seen.Add($name) | Out-Null
                    $stamp = Get-Date -Format "HH:mm:ss"
                    $msg = "[$stamp] Opened: $name"
                    $listBox.Invoke([action]{ $listBox.Items.Add($msg) }) | Out-Null
                }
            }
        })
        $timer.Start()
        $form.Add_Shown({ $form.Activate() })
        $form.Add_Closing({ $timer.Stop(); $timer.Dispose() })
        [void] $form.ShowDialog()
    }

    Show-ProcessActiveHistory
} | Out-Null

# --- Finalize results ---
if (-not $step5Output) { $step5Output += "SUCCESS: No suspicious files, processes, or registry entries detected." }

Write-Section "Step 5: Downloads, Processes, Registry Scan" $step5Output
Wait-ForEnter -Message "Press Enter to finish the scan (PAH window must stay open!)"


# Overall Success
$overallSuccess = [math]::Round((($success1 + $success2 + $success3 + $success4) / ($total1 + $total2 + $total3 + $total4)) * 100, 0)
$overallColor = if ($overallSuccess -eq 100) { "Green" } else { "Red" }
Write-ColoredLine "OVERALL SUCCESS: $overallSuccess%" $overallColor

# Cleanup file watcher
Unregister-Event -SourceIdentifier FileCreated -ErrorAction SilentlyContinue
Unregister-Event -SourceIdentifier FileChanged -ErrorAction SilentlyContinue

Wait-ForEnter -Message "Press Enter to Exit"
exit
